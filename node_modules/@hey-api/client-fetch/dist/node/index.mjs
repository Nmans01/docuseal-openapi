const e=/\{[^{}]+\}/g,t=({allowReserved:e,name:t,value:r})=>{if(null==r)return"";if("object"==typeof r)throw new Error("Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these.");return`${t}=${e?r:encodeURIComponent(r)}`},r=({allowReserved:e,explode:r,name:s,style:a,value:n})=>{if(!r){const t=(e?n:n.map((e=>encodeURIComponent(e)))).join((e=>{switch(e){case"form":default:return",";case"pipeDelimited":return"|";case"spaceDelimited":return"%20"}})(a));switch(a){case"label":return`.${t}`;case"matrix":return`;${s}=${t}`;case"simple":return t;default:return`${s}=${t}`}}const o=(e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}})(a),l=n.map((r=>"label"===a||"simple"===a?e?r:encodeURIComponent(r):t({allowReserved:e,name:s,value:r}))).join(o);return"label"===a||"matrix"===a?o+l:l},s=({allowReserved:e,explode:r,name:s,style:a,value:n})=>{if(n instanceof Date)return`${s}=${n.toISOString()}`;if("deepObject"!==a&&!r){let t=[];Object.entries(n).forEach((([r,s])=>{t=[...t,r,e?s:encodeURIComponent(s)]}));const r=t.join(",");switch(a){case"form":return`${s}=${r}`;case"label":return`.${r}`;case"matrix":return`;${s}=${r}`;default:return r}}const o=(e=>{switch(e){case"label":return".";case"matrix":return";";case"simple":return",";default:return"&"}})(a),l=Object.entries(n).map((([r,n])=>t({allowReserved:e,name:"deepObject"===a?`${s}[${r}]`:r,value:n}))).join(o);return"label"===a||"matrix"===a?o+l:l},a=({allowReserved:e,array:a,object:n}={})=>o=>{let l=[];if(o&&"object"==typeof o)for(const i in o){const c=o[i];null!=c&&(l=Array.isArray(c)?[...l,r({allowReserved:e,explode:!0,name:i,style:"form",value:c,...a})]:"object"!=typeof c?[...l,t({allowReserved:e,name:i,value:c})]:[...l,s({allowReserved:e,explode:!0,name:i,style:"deepObject",value:c,...n})])}return l.join("&")},n=({baseUrl:a,path:n,query:o,querySerializer:l,url:i})=>{let c=a+(i.startsWith("/")?i:`/${i}`);n&&(c=(({path:a,url:n})=>{let o=n;const l=n.match(e);if(l)for(const e of l){let n=!1,l=e.substring(1,e.length-1),i="simple";l.endsWith("*")&&(n=!0,l=l.substring(0,l.length-1)),l.startsWith(".")?(l=l.substring(1),i="label"):l.startsWith(";")&&(l=l.substring(1),i="matrix");const c=a[l];null!=c&&(o=Array.isArray(c)?o.replace(e,r({explode:n,name:l,style:i,value:c})):"object"!=typeof c?"matrix"!==i?o.replace(e,"label"===i?`.${c}`:c):o.replace(e,`;${t({name:l,value:c})}`):o.replace(e,s({explode:n,name:l,style:i,value:c})))}return o})({path:n,url:c}));let u=o?l(o):"";return u.startsWith("?")&&(u=u.substring(1)),u&&(c+=`?${u}`),c},o=(e,t)=>{const r={...e,...t};return r.baseUrl?.endsWith("/")&&(r.baseUrl=r.baseUrl.substring(0,r.baseUrl.length-1)),r.headers=l(e.headers,t.headers),r},l=(...e)=>{const t=new Headers;for(const r of e){if(!r||"object"!=typeof r)continue;const e=r instanceof Headers?r.entries():Object.entries(r);for(const[r,s]of e)if(null===s)t.delete(r);else if(Array.isArray(s))for(const e of s)t.append(r,e);else void 0!==s&&t.set(r,"object"==typeof s?JSON.stringify(s):s)}return t};class i{_fns;constructor(){this._fns=[]}eject(e){const t=this._fns.indexOf(e);-1!==t&&(this._fns=[...this._fns.slice(0,t),...this._fns.slice(t+1)])}use(e){this._fns=[...this._fns,e]}}const c=(e,t,r)=>{"string"==typeof r||r instanceof Blob?e.append(t,r):e.append(t,JSON.stringify(r))},u={bodySerializer:e=>{const t=new FormData;return Object.entries(e).forEach((([e,r])=>{null!=r&&(Array.isArray(r)?r.forEach((r=>c(t,e,r))):c(t,e,r))})),t}},d={bodySerializer:e=>JSON.stringify(e)},p=(e,t,r)=>{"string"==typeof r?e.append(t,r):e.append(t,JSON.stringify(r))},f={bodySerializer:e=>{const t=new URLSearchParams;return Object.entries(e).forEach((([e,r])=>{null!=r&&(Array.isArray(r)?r.forEach((r=>p(t,e,r))):p(t,e,r))})),t}},h=a({allowReserved:!1,array:{explode:!0,style:"form"},object:{explode:!0,style:"deepObject"}}),y={"Content-Type":"application/json"},m=(e={})=>({...d,baseUrl:"",fetch:globalThis.fetch,headers:y,parseAs:"auto",querySerializer:h,...e}),b=(e={})=>{let t=o(m(),e);const r=()=>({...t}),s={request:new i,response:new i},c=async e=>{const r={...t,...e,headers:l(t.headers,e.headers)};r.body&&r.bodySerializer&&(r.body=r.bodySerializer(r.body)),r.body||r.headers.delete("Content-Type");const o=n({baseUrl:r.baseUrl??"",path:r.path,query:r.query,querySerializer:"function"==typeof r.querySerializer?r.querySerializer:a(r.querySerializer),url:r.url}),i={redirect:"follow",...r};let c=new Request(o,i);for(const e of s.request._fns)c=await e(c,r);const u=r.fetch;let d=await u(c);for(const e of s.response._fns)d=await e(d,c,r);const p={request:c,response:d};if(d.ok){if(204===d.status||"0"===d.headers.get("Content-Length"))return{data:{},...p};if("stream"===r.parseAs)return{data:d.body,...p};const e=("auto"===r.parseAs?(e=>{if(e)return e.startsWith("application/json")||e.endsWith("+json")?"json":"multipart/form-data"===e?"formData":["application/","audio/","image/","video/"].some((t=>e.startsWith(t)))?"blob":e.startsWith("text/")?"text":void 0})(d.headers.get("Content-Type")):r.parseAs)??"json";let t=await d[e]();return"json"===e&&r.responseTransformer&&(t=await r.responseTransformer(t)),{data:t,...p}}let f=await d.text();if(r.throwOnError)throw new Error(f);try{f=JSON.parse(f)}catch{}return{error:f||{},...p}};return{connect:e=>c({...e,method:"CONNECT"}),delete:e=>c({...e,method:"DELETE"}),get:e=>c({...e,method:"GET"}),getConfig:r,head:e=>c({...e,method:"HEAD"}),interceptors:s,options:e=>c({...e,method:"OPTIONS"}),patch:e=>c({...e,method:"PATCH"}),post:e=>c({...e,method:"POST"}),put:e=>c({...e,method:"PUT"}),request:c,setConfig:e=>(t=o(t,e),r()),trace:e=>c({...e,method:"TRACE"})}};export{b as createClient,m as createConfig,u as formDataBodySerializer,d as jsonBodySerializer,f as urlSearchParamsBodySerializer};
