/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * DocuSeal API
 * DocuSeal API specs
 *
 * OpenAPI spec version: 1.0.0
 * Contact: admin@docuseal.co
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import { Configuration } from "./configuration";

const isomorphicFetch = fetch;

const BASE_PATH = "https://api.docuseal.co".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface IdCloneBody
 */
export interface IdCloneBody {
    /**
     * Template name. Existing name with (Clone) suffix will be used if not specified.
     * @type {string}
     * @memberof IdCloneBody
     */
    name?: string;
    /**
     * The folder's name to which the template should be cloned.
     * @type {string}
     * @memberof IdCloneBody
     */
    folderName?: string;
    /**
     * Your application-specific unique string key to identify this template within your app.
     * @type {string}
     * @memberof IdCloneBody
     */
    externalId?: string;
}
/**
 * 
 * @export
 * @interface IdDocumentsBody
 */
export interface IdDocumentsBody {
    /**
     * The list of documents to add or replace in the template.
     * @type {Array<TemplatesiddocumentsDocuments>}
     * @memberof IdDocumentsBody
     */
    documents?: Array<TemplatesiddocumentsDocuments>;
    /**
     * Set to `true` to merge all existing and new documents into a single PDF document in the template.
     * @type {boolean}
     * @memberof IdDocumentsBody
     */
    merge?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * List of templates.
     * @type {Array<InlineResponse200Data>}
     * @memberof InlineResponse200
     */
    data?: Array<InlineResponse200Data>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse200
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * Unique identifier of the document template.
     * @type {number}
     * @memberof InlineResponse2001
     */
    id?: number;
    /**
     * Unique slug of the document template.
     * @type {string}
     * @memberof InlineResponse2001
     */
    slug?: string;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse20011Schema>}
     * @memberof InlineResponse2001
     */
    schema?: Array<InlineResponse20011Schema>;
    /**
     * List of fields to be filled in the template.
     * @type {Array<InlineResponse20011Fields>}
     * @memberof InlineResponse2001
     */
    fields?: Array<InlineResponse20011Fields>;
    /**
     * 
     * @type {Array<InlineResponse20011Submitters>}
     * @memberof InlineResponse2001
     */
    submitters?: Array<InlineResponse20011Submitters>;
    /**
     * Unique identifier of the author of the template.
     * @type {number}
     * @memberof InlineResponse2001
     */
    authorId?: number;
    /**
     * Unique identifier of the account of the template.
     * @type {number}
     * @memberof InlineResponse2001
     */
    accountId?: number;
    /**
     * Date and time when the template was archived.
     * @type {string}
     * @memberof InlineResponse2001
     */
    archivedAt?: string;
    /**
     * Date and time when the template was created.
     * @type {string}
     * @memberof InlineResponse2001
     */
    createdAt?: string;
    /**
     * Date and time when the template was updated.
     * @type {string}
     * @memberof InlineResponse2001
     */
    updatedAt?: string;
    /**
     * Source of the template.
     * @type {string}
     * @memberof InlineResponse2001
     */
    source?: string;
    /**
     * Identifier of the template in the external system.
     * @type {string}
     * @memberof InlineResponse2001
     */
    externalId?: string;
    /**
     * Unique identifier of the folder where the template is placed.
     * @type {number}
     * @memberof InlineResponse2001
     */
    folderId?: number;
    /**
     * Folder name where the template is placed.
     * @type {string}
     * @memberof InlineResponse2001
     */
    folderName?: string;
    /**
     * 
     * @type {InlineResponse200Author}
     * @memberof InlineResponse2001
     */
    author?: InlineResponse200Author;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse200Documents>}
     * @memberof InlineResponse2001
     */
    documents?: Array<InlineResponse200Documents>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {Array<InlineResponse20010Data>}
     * @memberof InlineResponse20010
     */
    data?: Array<InlineResponse20010Data>;
    /**
     * 
     * @type {InlineResponse20010Pagination}
     * @memberof InlineResponse20010
     */
    pagination?: InlineResponse20010Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Data
 */
export interface InlineResponse20010Data {
    /**
     * Submitter unique ID number.
     * @type {number}
     * @memberof InlineResponse20010Data
     */
    id?: number;
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse20010Data
     */
    submissionId?: number;
    /**
     * Submitter UUID.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    uuid?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    email?: string;
    /**
     * Unique slug of the submitter form.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    slug?: string;
    /**
     * The date and time when the signing request was sent to the submitter.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    sentAt?: string;
    /**
     * The date and time when the submitter opened the signing form.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    openedAt?: string;
    /**
     * The date and time when the submitter completed the signing form.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    completedAt?: string;
    /**
     * The date and time when the submitter was created.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    createdAt?: string;
    /**
     * The date and time when the submitter was last updated.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    updatedAt?: string;
    /**
     * Submitter name.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    name?: string;
    /**
     * Submitter phone number.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    phone?: string;
    /**
     * 
     * @type {Array<InlineResponse20010SubmissionEvents>}
     * @memberof InlineResponse20010Data
     */
    submissionEvents?: Array<InlineResponse20010SubmissionEvents>;
    /**
     * An array of pre-filled values for the submission.
     * @type {Array<InlineResponse20010Values>}
     * @memberof InlineResponse20010Data
     */
    values?: Array<InlineResponse20010Values>;
    /**
     * An array of documents that the submitter has to sign.
     * @type {Array<InlineResponse20010Documents>}
     * @memberof InlineResponse20010Data
     */
    documents?: Array<InlineResponse20010Documents>;
    /**
     * The role of the submitter in the signing process.
     * @type {string}
     * @memberof InlineResponse20010Data
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Documents
 */
export interface InlineResponse20010Documents {
    /**
     * Document name.
     * @type {string}
     * @memberof InlineResponse20010Documents
     */
    name?: string;
    /**
     * Document URL.
     * @type {string}
     * @memberof InlineResponse20010Documents
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Pagination
 */
export interface InlineResponse20010Pagination {
    /**
     * Submitters count.
     * @type {number}
     * @memberof InlineResponse20010Pagination
     */
    count?: number;
    /**
     * The ID of the submitter after which the next page starts.
     * @type {number}
     * @memberof InlineResponse20010Pagination
     */
    next?: number;
    /**
     * The ID of the submitter before which the previous page ends.
     * @type {number}
     * @memberof InlineResponse20010Pagination
     */
    prev?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20010SubmissionEvents
 */
export interface InlineResponse20010SubmissionEvents {
    /**
     * Unique identifier of the submission event.
     * @type {number}
     * @memberof InlineResponse20010SubmissionEvents
     */
    id?: number;
    /**
     * Unique identifier of the submitter that triggered the event.
     * @type {number}
     * @memberof InlineResponse20010SubmissionEvents
     */
    submitterId?: number;
    /**
     * Event type.
     * @type {string}
     * @memberof InlineResponse20010SubmissionEvents
     */
    eventType?: string;
    /**
     * Date and time when the event was triggered.
     * @type {string}
     * @memberof InlineResponse20010SubmissionEvents
     */
    eventTimestamp?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Values
 */
export interface InlineResponse20010Values {
    /**
     * Document template field name
     * @type {string}
     * @memberof InlineResponse20010Values
     */
    field?: string;
    /**
     * Pre-filled value of the field.
     * @type {string}
     * @memberof InlineResponse20010Values
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * Template unique ID number.
     * @type {number}
     * @memberof InlineResponse20011
     */
    id?: number;
    /**
     * Unique slug of the document template.
     * @type {string}
     * @memberof InlineResponse20011
     */
    slug?: string;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse20011Schema>}
     * @memberof InlineResponse20011
     */
    schema?: Array<InlineResponse20011Schema>;
    /**
     * List of fields to be filled in the template.
     * @type {Array<InlineResponse20011Fields>}
     * @memberof InlineResponse20011
     */
    fields?: Array<InlineResponse20011Fields>;
    /**
     * 
     * @type {Array<InlineResponse20011Submitters>}
     * @memberof InlineResponse20011
     */
    submitters?: Array<InlineResponse20011Submitters>;
    /**
     * Unique identifier of the author of the template.
     * @type {number}
     * @memberof InlineResponse20011
     */
    authorId?: number;
    /**
     * Unique identifier of the account of the template.
     * @type {number}
     * @memberof InlineResponse20011
     */
    accountId?: number;
    /**
     * Date and time when the template was archived.
     * @type {string}
     * @memberof InlineResponse20011
     */
    archivedAt?: string;
    /**
     * Date and time when the template was created.
     * @type {string}
     * @memberof InlineResponse20011
     */
    createdAt?: string;
    /**
     * Date and time when the template was updated.
     * @type {string}
     * @memberof InlineResponse20011
     */
    updatedAt?: string;
    /**
     * Source of the template.
     * @type {string}
     * @memberof InlineResponse20011
     */
    source?: string;
    /**
     * Unique identifier of the folder where the template is placed.
     * @type {number}
     * @memberof InlineResponse20011
     */
    folderId?: number;
    /**
     * Folder name where the template is placed.
     * @type {string}
     * @memberof InlineResponse20011
     */
    folderName?: string;
    /**
     * 
     * @type {InlineResponse20011Author}
     * @memberof InlineResponse20011
     */
    author?: InlineResponse20011Author;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse20011Documents>}
     * @memberof InlineResponse20011
     */
    documents?: Array<InlineResponse20011Documents>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Areas
 */
export interface InlineResponse20011Areas {
    /**
     * X coordinate of the area where the field is located in the document.
     * @type {number}
     * @memberof InlineResponse20011Areas
     */
    x?: number;
    /**
     * Y coordinate of the area where the field is located in the document.
     * @type {number}
     * @memberof InlineResponse20011Areas
     */
    y?: number;
    /**
     * Width of the area where the field is located in the document.
     * @type {number}
     * @memberof InlineResponse20011Areas
     */
    w?: number;
    /**
     * Height of the area where the field is located in the document.
     * @type {number}
     * @memberof InlineResponse20011Areas
     */
    h?: number;
    /**
     * Unique identifier of the attached document where the field is located.
     * @type {string}
     * @memberof InlineResponse20011Areas
     */
    attachmentUuid?: string;
    /**
     * Page number of the attached document where the field is located.
     * @type {number}
     * @memberof InlineResponse20011Areas
     */
    page?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Author
 */
export interface InlineResponse20011Author {
    /**
     * Author unique ID number.
     * @type {number}
     * @memberof InlineResponse20011Author
     */
    id?: number;
    /**
     * First name of the author.
     * @type {string}
     * @memberof InlineResponse20011Author
     */
    firstName?: string;
    /**
     * Last name of the author.
     * @type {string}
     * @memberof InlineResponse20011Author
     */
    lastName?: string;
    /**
     * Author email.
     * @type {string}
     * @memberof InlineResponse20011Author
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Documents
 */
export interface InlineResponse20011Documents {
    /**
     * Document unique ID number.
     * @type {number}
     * @memberof InlineResponse20011Documents
     */
    id?: number;
    /**
     * Unique identifier of the document.
     * @type {string}
     * @memberof InlineResponse20011Documents
     */
    uuid?: string;
    /**
     * URL of the document.
     * @type {string}
     * @memberof InlineResponse20011Documents
     */
    url?: string;
    /**
     * Document preview image URL.
     * @type {string}
     * @memberof InlineResponse20011Documents
     */
    previewImageUrl?: string;
    /**
     * Document filename.
     * @type {string}
     * @memberof InlineResponse20011Documents
     */
    filename?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Fields
 */
export interface InlineResponse20011Fields {
    /**
     * Unique identifier of the field.
     * @type {string}
     * @memberof InlineResponse20011Fields
     */
    uuid?: string;
    /**
     * Unique identifier of the submitter that filled the field.
     * @type {string}
     * @memberof InlineResponse20011Fields
     */
    submitterUuid?: string;
    /**
     * Field name.
     * @type {string}
     * @memberof InlineResponse20011Fields
     */
    name?: string;
    /**
     * Indicates if the field is required.
     * @type {boolean}
     * @memberof InlineResponse20011Fields
     */
    required?: boolean;
    /**
     * List of areas where the field is located in the document.
     * @type {Array<InlineResponse20011Areas>}
     * @memberof InlineResponse20011Fields
     */
    areas?: Array<InlineResponse20011Areas>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Schema
 */
export interface InlineResponse20011Schema {
    /**
     * Unique indentifier of attached document to the template.
     * @type {string}
     * @memberof InlineResponse20011Schema
     */
    attachmentUuid?: string;
    /**
     * Name of the attached document to the template.
     * @type {string}
     * @memberof InlineResponse20011Schema
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Submitters
 */
export interface InlineResponse20011Submitters {
    /**
     * Submitter name.
     * @type {string}
     * @memberof InlineResponse20011Submitters
     */
    name?: string;
    /**
     * Unique identifier of the submitter.
     * @type {string}
     * @memberof InlineResponse20011Submitters
     */
    uuid?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * Template unique ID number.
     * @type {number}
     * @memberof InlineResponse20012
     */
    id?: number;
    /**
     * Unique slug of the document template.
     * @type {string}
     * @memberof InlineResponse20012
     */
    slug?: string;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse20011Schema>}
     * @memberof InlineResponse20012
     */
    schema?: Array<InlineResponse20011Schema>;
    /**
     * List of fields to be filled in the template.
     * @type {Array<InlineResponse20011Fields>}
     * @memberof InlineResponse20012
     */
    fields?: Array<InlineResponse20011Fields>;
    /**
     * 
     * @type {Array<InlineResponse20011Submitters>}
     * @memberof InlineResponse20012
     */
    submitters?: Array<InlineResponse20011Submitters>;
    /**
     * Unique identifier of the author of the template.
     * @type {number}
     * @memberof InlineResponse20012
     */
    authorId?: number;
    /**
     * Unique identifier of the account of the template.
     * @type {number}
     * @memberof InlineResponse20012
     */
    accountId?: number;
    /**
     * Date and time when the template was archived.
     * @type {string}
     * @memberof InlineResponse20012
     */
    archivedAt?: string;
    /**
     * Date and time when the template was created.
     * @type {string}
     * @memberof InlineResponse20012
     */
    createdAt?: string;
    /**
     * Date and time when the template was updated.
     * @type {string}
     * @memberof InlineResponse20012
     */
    updatedAt?: string;
    /**
     * Source of the template.
     * @type {string}
     * @memberof InlineResponse20012
     */
    source?: string;
    /**
     * Identifier of the template in the external system.
     * @type {string}
     * @memberof InlineResponse20012
     */
    externalId?: string;
    /**
     * Unique identifier of the folder where the template is placed.
     * @type {number}
     * @memberof InlineResponse20012
     */
    folderId?: number;
    /**
     * Folder name where the template is placed.
     * @type {string}
     * @memberof InlineResponse20012
     */
    folderName?: string;
    /**
     * 
     * @type {InlineResponse20011Author}
     * @memberof InlineResponse20012
     */
    author?: InlineResponse20011Author;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse20011Documents>}
     * @memberof InlineResponse20012
     */
    documents?: Array<InlineResponse20011Documents>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * Template unique ID number.
     * @type {number}
     * @memberof InlineResponse2002
     */
    id?: number;
    /**
     * Date and time when the template was last updated.
     * @type {string}
     * @memberof InlineResponse2002
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * Template unique ID number.
     * @type {number}
     * @memberof InlineResponse2003
     */
    id?: number;
    /**
     * Date and time when the template was archived.
     * @type {string}
     * @memberof InlineResponse2003
     */
    archivedAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<InlineResponse2004Data>}
     * @memberof InlineResponse2004
     */
    data?: Array<InlineResponse2004Data>;
    /**
     * 
     * @type {InlineResponse2004Pagination}
     * @memberof InlineResponse2004
     */
    pagination?: InlineResponse2004Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Data
 */
export interface InlineResponse2004Data {
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse2004Data
     */
    id?: number;
    /**
     * The source of the submission.
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    source?: string;
    /**
     * Unique slug of the submission.
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    slug?: string;
    /**
     * The order of submitters.
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    submittersOrder?: string;
    /**
     * Audit log file URL.
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    auditLogUrl?: string;
    /**
     * The date and time when the submission was created.
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    createdAt?: string;
    /**
     * The date and time when the submission was last updated.
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    updatedAt?: string;
    /**
     * The date and time when the submission was archived.
     * @type {string}
     * @memberof InlineResponse2004Data
     */
    archivedAt?: string;
    /**
     * The list of submitters.
     * @type {Array<InlineResponse2004Submitters>}
     * @memberof InlineResponse2004Data
     */
    submitters?: Array<InlineResponse2004Submitters>;
    /**
     * 
     * @type {InlineResponse2006Template}
     * @memberof InlineResponse2004Data
     */
    template?: InlineResponse2006Template;
    /**
     * 
     * @type {InlineResponse2006CreatedByUser}
     * @memberof InlineResponse2004Data
     */
    createdByUser?: InlineResponse2006CreatedByUser;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Pagination
 */
export interface InlineResponse2004Pagination {
    /**
     * Submissions count.
     * @type {number}
     * @memberof InlineResponse2004Pagination
     */
    count?: number;
    /**
     * The ID of the submission after which the next page starts.
     * @type {number}
     * @memberof InlineResponse2004Pagination
     */
    next?: number;
    /**
     * The ID of the submission before which the previous page ends.
     * @type {number}
     * @memberof InlineResponse2004Pagination
     */
    prev?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Submitters
 */
export interface InlineResponse2004Submitters {
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse2004Submitters
     */
    id?: number;
    /**
     * Submitter UUID.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    uuid?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    email?: string;
    /**
     * Unique key to be used in the form signing link and embedded form.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    slug?: string;
    /**
     * The date and time when the signing request was sent to the submitter.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    sentAt?: string;
    /**
     * The date and time when the submitter opened the signing form.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    openedAt?: string;
    /**
     * The date and time when the submitter completed the signing form.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    completedAt?: string;
    /**
     * The date and time when the submitter was created.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    createdAt?: string;
    /**
     * The date and time when the submitter was last updated.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    updatedAt?: string;
    /**
     * Submitter name.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    name?: string;
    /**
     * Submitter phone number.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    phone?: string;
    /**
     * Your application-specific unique string key to identify this submitter within your app.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    externalId?: string;
    /**
     * The status of signing request for the submitter.
     * @type {string}
     * @memberof InlineResponse2004Submitters
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * Submitter unique ID number.
     * @type {number}
     * @memberof InlineResponse2005
     */
    id?: number;
    /**
     * Submission UUID.
     * @type {number}
     * @memberof InlineResponse2005
     */
    submissionId?: number;
    /**
     * Submitter UUID
     * @type {string}
     * @memberof InlineResponse2005
     */
    uuid?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof InlineResponse2005
     */
    email?: string;
    /**
     * Unique key to be used in the signing form URL.
     * @type {string}
     * @memberof InlineResponse2005
     */
    slug?: string;
    /**
     * An array of objects with pre-filled values for the submission. Use field names for keys of the object.
     * @type {any}
     * @memberof InlineResponse2005
     */
    values?: any;
    /**
     * 
     * @type {any}
     * @memberof InlineResponse2005
     */
    metadata?: any;
    /**
     * User agent string of the submitter.
     * @type {string}
     * @memberof InlineResponse2005
     */
    ua?: string;
    /**
     * IP address of the submitter.
     * @type {string}
     * @memberof InlineResponse2005
     */
    ip?: string;
    /**
     * The date and time when the signing request was sent to the submitter.
     * @type {string}
     * @memberof InlineResponse2005
     */
    sentAt?: string;
    /**
     * The date and time when the submitter opened the signing form.
     * @type {string}
     * @memberof InlineResponse2005
     */
    openedAt?: string;
    /**
     * The date and time when the submitter completed the signing form.
     * @type {string}
     * @memberof InlineResponse2005
     */
    completedAt?: string;
    /**
     * The date and time when the submitter was created.
     * @type {string}
     * @memberof InlineResponse2005
     */
    createdAt?: string;
    /**
     * The date and time when the submitter was last updated.
     * @type {string}
     * @memberof InlineResponse2005
     */
    updatedAt?: string;
    /**
     * The name of the submitter.
     * @type {string}
     * @memberof InlineResponse2005
     */
    name?: string;
    /**
     * The phone number of the submitter.
     * @type {string}
     * @memberof InlineResponse2005
     */
    phone?: string;
    /**
     * Your application-specific unique string key to identify this submitter within your app.
     * @type {string}
     * @memberof InlineResponse2005
     */
    externalId?: string;
    /**
     * 
     * @type {SubmissionsPreferences}
     * @memberof InlineResponse2005
     */
    preferences?: SubmissionsPreferences;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse2006
     */
    id?: number;
    /**
     * Unique slug of the submission.
     * @type {string}
     * @memberof InlineResponse2006
     */
    slug?: string;
    /**
     * The source of the submission.
     * @type {string}
     * @memberof InlineResponse2006
     */
    source?: string;
    /**
     * The order of submitters.
     * @type {string}
     * @memberof InlineResponse2006
     */
    submittersOrder?: string;
    /**
     * Audit log file URL.
     * @type {string}
     * @memberof InlineResponse2006
     */
    auditLogUrl?: string;
    /**
     * The date and time when the submission was created.
     * @type {string}
     * @memberof InlineResponse2006
     */
    createdAt?: string;
    /**
     * The date and time when the submission was last updated.
     * @type {string}
     * @memberof InlineResponse2006
     */
    updatedAt?: string;
    /**
     * The date and time when the submission was archived.
     * @type {string}
     * @memberof InlineResponse2006
     */
    archivedAt?: string;
    /**
     * The list of submitters.
     * @type {Array<InlineResponse2006Submitters>}
     * @memberof InlineResponse2006
     */
    submitters?: Array<InlineResponse2006Submitters>;
    /**
     * 
     * @type {InlineResponse2006Template}
     * @memberof InlineResponse2006
     */
    template?: InlineResponse2006Template;
    /**
     * 
     * @type {InlineResponse2006CreatedByUser}
     * @memberof InlineResponse2006
     */
    createdByUser?: InlineResponse2006CreatedByUser;
    /**
     * 
     * @type {Array<InlineResponse2006SubmissionEvents>}
     * @memberof InlineResponse2006
     */
    submissionEvents?: Array<InlineResponse2006SubmissionEvents>;
    /**
     * 
     * @type {Array<InlineResponse20010Documents>}
     * @memberof InlineResponse2006
     */
    documents?: Array<InlineResponse20010Documents>;
    /**
     * The status of the submission.
     * @type {string}
     * @memberof InlineResponse2006
     */
    status?: string;
    /**
     * The date and time when the submission was fully completed.
     * @type {string}
     * @memberof InlineResponse2006
     */
    completedAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006CreatedByUser
 */
export interface InlineResponse2006CreatedByUser {
    /**
     * Unique identifier of the user who created the submission.
     * @type {number}
     * @memberof InlineResponse2006CreatedByUser
     */
    id?: number;
    /**
     * The first name of the user who created the submission.
     * @type {string}
     * @memberof InlineResponse2006CreatedByUser
     */
    firstName?: string;
    /**
     * The last name of the user who created the submission.
     * @type {string}
     * @memberof InlineResponse2006CreatedByUser
     */
    lastName?: string;
    /**
     * The email address of the user who created the submission.
     * @type {string}
     * @memberof InlineResponse2006CreatedByUser
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006SubmissionEvents
 */
export interface InlineResponse2006SubmissionEvents {
    /**
     * Submission event unique ID number.
     * @type {number}
     * @memberof InlineResponse2006SubmissionEvents
     */
    id?: number;
    /**
     * Unique identifier of the submitter that triggered the event.
     * @type {number}
     * @memberof InlineResponse2006SubmissionEvents
     */
    submitterId?: number;
    /**
     * Event type.
     * @type {string}
     * @memberof InlineResponse2006SubmissionEvents
     */
    eventType?: string;
    /**
     * Date and time when the event was triggered.
     * @type {string}
     * @memberof InlineResponse2006SubmissionEvents
     */
    eventTimestamp?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Submitters
 */
export interface InlineResponse2006Submitters {
    /**
     * Submitter unique ID number.
     * @type {number}
     * @memberof InlineResponse2006Submitters
     */
    id?: number;
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse2006Submitters
     */
    submissionId?: number;
    /**
     * Submitter UUID
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    uuid?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    email?: string;
    /**
     * Unique key to be used in the form signing link and embedded form.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    slug?: string;
    /**
     * The date and time when the signing request was sent to the submitter.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    sentAt?: string;
    /**
     * The date and time when the submitter opened the signing form.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    openedAt?: string;
    /**
     * The date and time when the submitter completed the signing form.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    completedAt?: string;
    /**
     * The date and time when the submitter was created.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    createdAt?: string;
    /**
     * The date and time when the submitter was last updated.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    updatedAt?: string;
    /**
     * Submitter name.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    name?: string;
    /**
     * Submitter phone number.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    phone?: string;
    /**
     * Your application-specific unique string key to identify this submitter within your app.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    externalId?: string;
    /**
     * The status of signing request for the submitter.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    status?: string;
    /**
     * An array of pre-filled values for the submission.
     * @type {Array<InlineResponse20010Values>}
     * @memberof InlineResponse2006Submitters
     */
    values?: Array<InlineResponse20010Values>;
    /**
     * An array of documents that the submitter has to sign.
     * @type {Array<InlineResponse20010Documents>}
     * @memberof InlineResponse2006Submitters
     */
    documents?: Array<InlineResponse20010Documents>;
    /**
     * The role of the submitter in the signing process.
     * @type {string}
     * @memberof InlineResponse2006Submitters
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Template
 */
export interface InlineResponse2006Template {
    /**
     * Template unique ID number.
     * @type {number}
     * @memberof InlineResponse2006Template
     */
    id?: number;
    /**
     * The name of the submission template.
     * @type {string}
     * @memberof InlineResponse2006Template
     */
    name?: string;
    /**
     * Your application-specific unique string key to identify this template within your app.
     * @type {string}
     * @memberof InlineResponse2006Template
     */
    externalId?: string;
    /**
     * Folder name where the template is located.
     * @type {string}
     * @memberof InlineResponse2006Template
     */
    folderName?: string;
    /**
     * The date and time when the submission template was created.
     * @type {string}
     * @memberof InlineResponse2006Template
     */
    createdAt?: string;
    /**
     * The date and time when the submission template was last updated.
     * @type {string}
     * @memberof InlineResponse2006Template
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse2007
     */
    id?: number;
    /**
     * Date and time when the submission was archived.
     * @type {string}
     * @memberof InlineResponse2007
     */
    archivedAt?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * Submitter unique ID number.
     * @type {number}
     * @memberof InlineResponse2008
     */
    id?: number;
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse2008
     */
    submissionId?: number;
    /**
     * Submitter UUID.
     * @type {string}
     * @memberof InlineResponse2008
     */
    uuid?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof InlineResponse2008
     */
    email?: string;
    /**
     * Unique key to be used in the form signing link and embedded form.
     * @type {string}
     * @memberof InlineResponse2008
     */
    slug?: string;
    /**
     * The date and time when the signing request was sent to the submitter.
     * @type {string}
     * @memberof InlineResponse2008
     */
    sentAt?: string;
    /**
     * The date and time when the submitter opened the signing form.
     * @type {string}
     * @memberof InlineResponse2008
     */
    openedAt?: string;
    /**
     * The date and time when the submitter completed the signing form.
     * @type {string}
     * @memberof InlineResponse2008
     */
    completedAt?: string;
    /**
     * The date and time when the submitter was created.
     * @type {string}
     * @memberof InlineResponse2008
     */
    createdAt?: string;
    /**
     * The date and time when the submitter was last updated.
     * @type {string}
     * @memberof InlineResponse2008
     */
    updatedAt?: string;
    /**
     * Submitter name.
     * @type {string}
     * @memberof InlineResponse2008
     */
    name?: string;
    /**
     * Submitter phone number.
     * @type {string}
     * @memberof InlineResponse2008
     */
    phone?: string;
    /**
     * 
     * @type {Array<InlineResponse2006SubmissionEvents>}
     * @memberof InlineResponse2008
     */
    submissionEvents?: Array<InlineResponse2006SubmissionEvents>;
    /**
     * An array of pre-filled values for the submission.
     * @type {Array<InlineResponse20010Values>}
     * @memberof InlineResponse2008
     */
    values?: Array<InlineResponse20010Values>;
    /**
     * An array of documents that the submitter has to sign.
     * @type {Array<InlineResponse20010Documents>}
     * @memberof InlineResponse2008
     */
    documents?: Array<InlineResponse20010Documents>;
    /**
     * The role of the submitter in the signing process.
     * @type {string}
     * @memberof InlineResponse2008
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * Submitter unique ID number.
     * @type {number}
     * @memberof InlineResponse2009
     */
    id?: number;
    /**
     * Submission unique ID number.
     * @type {number}
     * @memberof InlineResponse2009
     */
    submissionId?: number;
    /**
     * Submitter UUID.
     * @type {string}
     * @memberof InlineResponse2009
     */
    uuid?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof InlineResponse2009
     */
    email?: string;
    /**
     * Unique key to be used in the form signing link and embedded form.
     * @type {string}
     * @memberof InlineResponse2009
     */
    slug?: string;
    /**
     * The date and time when the signing request was sent to the submitter.
     * @type {string}
     * @memberof InlineResponse2009
     */
    sentAt?: string;
    /**
     * The date and time when the submitter opened the signing form.
     * @type {string}
     * @memberof InlineResponse2009
     */
    openedAt?: string;
    /**
     * The date and time when the submitter completed the signing form.
     * @type {string}
     * @memberof InlineResponse2009
     */
    completedAt?: string;
    /**
     * The date and time when the submitter was created.
     * @type {string}
     * @memberof InlineResponse2009
     */
    createdAt?: string;
    /**
     * The date and time when the submitter was last updated.
     * @type {string}
     * @memberof InlineResponse2009
     */
    updatedAt?: string;
    /**
     * Submitter name.
     * @type {string}
     * @memberof InlineResponse2009
     */
    name?: string;
    /**
     * Submitter phone number.
     * @type {string}
     * @memberof InlineResponse2009
     */
    phone?: string;
    /**
     * An array of pre-filled values for the submission.
     * @type {Array<InlineResponse20010Values>}
     * @memberof InlineResponse2009
     */
    values?: Array<InlineResponse20010Values>;
    /**
     * An array of documents that the submitter has to sign.
     * @type {Array<InlineResponse20010Documents>}
     * @memberof InlineResponse2009
     */
    documents?: Array<InlineResponse20010Documents>;
    /**
     * The role of the submitter in the signing process.
     * @type {string}
     * @memberof InlineResponse2009
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200Author
 */
export interface InlineResponse200Author {
    /**
     * Unique identifier of the author.
     * @type {number}
     * @memberof InlineResponse200Author
     */
    id?: number;
    /**
     * First name of the author.
     * @type {string}
     * @memberof InlineResponse200Author
     */
    firstName?: string;
    /**
     * Last name of the author.
     * @type {string}
     * @memberof InlineResponse200Author
     */
    lastName?: string;
    /**
     * Author email.
     * @type {string}
     * @memberof InlineResponse200Author
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200Data
 */
export interface InlineResponse200Data {
    /**
     * Unique identifier of the document template.
     * @type {number}
     * @memberof InlineResponse200Data
     */
    id?: number;
    /**
     * Unique slug of the document template.
     * @type {string}
     * @memberof InlineResponse200Data
     */
    slug?: string;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse20011Schema>}
     * @memberof InlineResponse200Data
     */
    schema?: Array<InlineResponse20011Schema>;
    /**
     * List of fields to be filled in the template.
     * @type {Array<InlineResponse20011Fields>}
     * @memberof InlineResponse200Data
     */
    fields?: Array<InlineResponse20011Fields>;
    /**
     * 
     * @type {Array<InlineResponse20011Submitters>}
     * @memberof InlineResponse200Data
     */
    submitters?: Array<InlineResponse20011Submitters>;
    /**
     * Unique identifier of the author of the template.
     * @type {number}
     * @memberof InlineResponse200Data
     */
    authorId?: number;
    /**
     * Unique identifier of the account of the template.
     * @type {number}
     * @memberof InlineResponse200Data
     */
    accountId?: number;
    /**
     * Date and time when the template was archived.
     * @type {string}
     * @memberof InlineResponse200Data
     */
    archivedAt?: string;
    /**
     * Date and time when the template was created.
     * @type {string}
     * @memberof InlineResponse200Data
     */
    createdAt?: string;
    /**
     * Date and time when the template was updated.
     * @type {string}
     * @memberof InlineResponse200Data
     */
    updatedAt?: string;
    /**
     * Source of the template.
     * @type {string}
     * @memberof InlineResponse200Data
     */
    source?: string;
    /**
     * Identifier of the template in the external system.
     * @type {string}
     * @memberof InlineResponse200Data
     */
    externalId?: string;
    /**
     * Unique identifier of the folder where the template is placed.
     * @type {number}
     * @memberof InlineResponse200Data
     */
    folderId?: number;
    /**
     * Folder name where the template is placed.
     * @type {string}
     * @memberof InlineResponse200Data
     */
    folderName?: string;
    /**
     * 
     * @type {InlineResponse200Author}
     * @memberof InlineResponse200Data
     */
    author?: InlineResponse200Author;
    /**
     * List of documents attached to the template.
     * @type {Array<InlineResponse200Documents>}
     * @memberof InlineResponse200Data
     */
    documents?: Array<InlineResponse200Documents>;
}
/**
 * 
 * @export
 * @interface InlineResponse200Documents
 */
export interface InlineResponse200Documents {
    /**
     * Unique identifier of the document.
     * @type {number}
     * @memberof InlineResponse200Documents
     */
    id?: number;
    /**
     * Unique identifier of the document.
     * @type {string}
     * @memberof InlineResponse200Documents
     */
    uuid?: string;
    /**
     * URL of the document.
     * @type {string}
     * @memberof InlineResponse200Documents
     */
    url?: string;
    /**
     * Document preview image URL.
     * @type {string}
     * @memberof InlineResponse200Documents
     */
    previewImageUrl?: string;
    /**
     * Document filename.
     * @type {string}
     * @memberof InlineResponse200Documents
     */
    filename?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200Pagination
 */
export interface InlineResponse200Pagination {
    /**
     * Templates count.
     * @type {number}
     * @memberof InlineResponse200Pagination
     */
    count?: number;
    /**
     * The ID of the tempate after which the next page starts.
     * @type {number}
     * @memberof InlineResponse200Pagination
     */
    next?: number;
    /**
     * The ID of the tempate before which the previous page ends.
     * @type {number}
     * @memberof InlineResponse200Pagination
     */
    prev?: number;
}
/**
 * 
 * @export
 * @interface SubmissionsBody
 */
export interface SubmissionsBody {
    /**
     * The unique identifier of the template. Document template forms can be created via Web UI, <a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">PDF and DOCX API</a>, or <a href=\"https://www.docuseal.co/guides/create-pdf-document-fillable-form-with-html-api\" class=\"link\">HTML API</a>.
     * @type {number}
     * @memberof SubmissionsBody
     */
    templateId: number;
    /**
     * Set `false` to disable signature request emails sending.
     * @type {boolean}
     * @memberof SubmissionsBody
     */
    sendEmail?: boolean;
    /**
     * Set `true` to send signature request via phone number and SMS.
     * @type {boolean}
     * @memberof SubmissionsBody
     */
    sendSms?: boolean;
    /**
     * Pass 'random' to send signature request emails to all parties right away. The order is 'preserved' by default so the second party will receive a signature request email only after the document is signed by the first party.
     * @type {string}
     * @memberof SubmissionsBody
     */
    order?: SubmissionsBody.OrderEnum;
    /**
     * Specify URL to redirect to after the submission completion.
     * @type {string}
     * @memberof SubmissionsBody
     */
    completedRedirectUrl?: string;
    /**
     * Specify BCC address to send signed documents to after the completion.
     * @type {string}
     * @memberof SubmissionsBody
     */
    bccCompleted?: string;
    /**
     * Specify Reply-To address to use in the notification emails.
     * @type {string}
     * @memberof SubmissionsBody
     */
    replyTo?: string;
    /**
     * Specify the expiration date and time after which the submission becomes unaccessible.
     * @type {string}
     * @memberof SubmissionsBody
     */
    expireAt?: string;
    /**
     * 
     * @type {SubmissionsMessage}
     * @memberof SubmissionsBody
     */
    message?: SubmissionsMessage;
    /**
     * The list of submitters for the submission.
     * @type {Array<SubmissionsSubmitters>}
     * @memberof SubmissionsBody
     */
    submitters: Array<SubmissionsSubmitters>;
}

/**
 * @export
 * @namespace SubmissionsBody
 */
export namespace SubmissionsBody {
    /**
     * @export
     * @enum {string}
     */
    export enum OrderEnum {
        Preserved = <any>'preserved',
        Random = <any>'random'
    }
}
/**
 * 
 * @export
 * @interface SubmissionsEmailsBody
 */
export interface SubmissionsEmailsBody {
    /**
     * The unique identifier of the template.
     * @type {number}
     * @memberof SubmissionsEmailsBody
     */
    templateId: number;
    /**
     * A comma-separated list of email addresses to send the submission to.
     * @type {string}
     * @memberof SubmissionsEmailsBody
     */
    emails: string;
    /**
     * Set `false` to disable signature request emails sending.
     * @type {boolean}
     * @memberof SubmissionsEmailsBody
     */
    sendEmail?: boolean;
    /**
     * 
     * @type {SubmissionsMessage}
     * @memberof SubmissionsEmailsBody
     */
    message?: SubmissionsMessage;
}
/**
 * 
 * @export
 * @interface SubmissionsFields
 */
export interface SubmissionsFields {
    /**
     * Document template field name
     * @type {string}
     * @memberof SubmissionsFields
     */
    name: string;
    /**
     * Default value of the field. Use base64 encoded file or a public URL to the image file to set default signature or image fields.
     * @type {string}
     * @memberof SubmissionsFields
     */
    defaultValue?: string;
    /**
     * HTML field validation pattern string based on https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/pattern specification.
     * @type {string}
     * @memberof SubmissionsFields
     */
    validationPattern?: string;
    /**
     * A custom message to display on pattern validation failure.
     * @type {string}
     * @memberof SubmissionsFields
     */
    invalidMessage?: string;
    /**
     * Set `true` to make it impossible for the submitter to edit predefined field value.
     * @type {boolean}
     * @memberof SubmissionsFields
     */
    readonly?: boolean;
}
/**
 * 
 * @export
 * @interface SubmissionsMessage
 */
export interface SubmissionsMessage {
    /**
     * Custom signature request email subject.
     * @type {string}
     * @memberof SubmissionsMessage
     */
    subject?: string;
    /**
     * Custom signature request email body. Can include the following variables: {{template.name}}, {{submitter.link}}, {{account.name}}.
     * @type {string}
     * @memberof SubmissionsMessage
     */
    body?: string;
}
/**
 * 
 * @export
 * @interface SubmissionsPreferences
 */
export interface SubmissionsPreferences {
    /**
     * Set `false` to disable signature request emails sending.
     * @type {boolean}
     * @memberof SubmissionsPreferences
     */
    sendEmail?: boolean;
    /**
     * Set `true` to send signature request via phone number and SMS.
     * @type {boolean}
     * @memberof SubmissionsPreferences
     */
    sendSms?: boolean;
}
/**
 * 
 * @export
 * @interface SubmissionsSubmitters
 */
export interface SubmissionsSubmitters {
    /**
     * The name of the submitter.
     * @type {string}
     * @memberof SubmissionsSubmitters
     */
    name?: string;
    /**
     * The role name or title of the submitter.
     * @type {string}
     * @memberof SubmissionsSubmitters
     */
    role?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof SubmissionsSubmitters
     */
    email: string;
    /**
     * The phone number of the submitter, formatted according to the E.164 standard.
     * @type {string}
     * @memberof SubmissionsSubmitters
     */
    phone?: string;
    /**
     * An object with pre-filled values for the submission. Use field names for keys of the object. For more configurations see `fields` param.
     * @type {any}
     * @memberof SubmissionsSubmitters
     */
    values?: any;
    /**
     * Your application-specific unique string key to identify this submitter within your app.
     * @type {string}
     * @memberof SubmissionsSubmitters
     */
    externalId?: string;
    /**
     * Pass `true` to mark submitter as completed and auto-signed via API.
     * @type {boolean}
     * @memberof SubmissionsSubmitters
     */
    completed?: boolean;
    /**
     * An object with pre-filled values for the submission. Use field names for keys of the object. For more configurations see `fields` param.
     * @type {any}
     * @memberof SubmissionsSubmitters
     */
    metadata?: any;
    /**
     * Set `false` to disable signature request emails sending.
     * @type {boolean}
     * @memberof SubmissionsSubmitters
     */
    sendEmail?: boolean;
    /**
     * Set `true` to send signature request via phone number and SMS.
     * @type {boolean}
     * @memberof SubmissionsSubmitters
     */
    sendSms?: boolean;
    /**
     * Submitter specific URL to redirect to after the submission completion.
     * @type {string}
     * @memberof SubmissionsSubmitters
     */
    completedRedirectUrl?: string;
    /**
     * A list of configurations for template document form fields.
     * @type {Array<SubmissionsFields>}
     * @memberof SubmissionsSubmitters
     */
    fields?: Array<SubmissionsFields>;
}
/**
 * 
 * @export
 * @interface SubmittersIdBody
 */
export interface SubmittersIdBody {
    /**
     * The name of the submitter.
     * @type {string}
     * @memberof SubmittersIdBody
     */
    name?: string;
    /**
     * The email address of the submitter.
     * @type {string}
     * @memberof SubmittersIdBody
     */
    email?: string;
    /**
     * The phone number of the submitter, formatted according to the E.164 standard.
     * @type {string}
     * @memberof SubmittersIdBody
     */
    phone?: string;
    /**
     * An object with pre-filled values for the submission. Use field names for keys of the object. For more configurations see `fields` param.
     * @type {any}
     * @memberof SubmittersIdBody
     */
    values?: any;
    /**
     * Your application-specific unique string key to identify this submitter within your app.
     * @type {string}
     * @memberof SubmittersIdBody
     */
    externalId?: string;
    /**
     * Set `true` to re-send signature request emails.
     * @type {boolean}
     * @memberof SubmittersIdBody
     */
    sendEmail?: boolean;
    /**
     * Set `true` to re-send signature request via phone number SMS.
     * @type {boolean}
     * @memberof SubmittersIdBody
     */
    sendSms?: boolean;
    /**
     * Specify Reply-To address to use in the notification emails.
     * @type {string}
     * @memberof SubmittersIdBody
     */
    replyTo?: string;
    /**
     * Submitter specific URL to redirect to after the submission completion.
     * @type {string}
     * @memberof SubmittersIdBody
     */
    completedRedirectUrl?: string;
    /**
     * Pass `true` to mark submitter as completed and auto-signed via API.
     * @type {boolean}
     * @memberof SubmittersIdBody
     */
    completed?: boolean;
    /**
     * 
     * @type {SubmissionsMessage}
     * @memberof SubmittersIdBody
     */
    message?: SubmissionsMessage;
    /**
     * A list of configurations for template document form fields.
     * @type {Array<SubmissionsFields>}
     * @memberof SubmittersIdBody
     */
    fields?: Array<SubmissionsFields>;
}
/**
 * 
 * @export
 * @interface TemplatesDocxBody
 */
export interface TemplatesDocxBody {
    /**
     * Name of the template
     * @type {string}
     * @memberof TemplatesDocxBody
     */
    name?: string;
    /**
     * Your application-specific unique string key to identify this template within your app. Existing template with specified `external_id` will be updated with a new document.
     * @type {string}
     * @memberof TemplatesDocxBody
     */
    externalId?: string;
    /**
     * The folder's name to which the template should be created.
     * @type {string}
     * @memberof TemplatesDocxBody
     */
    folderName?: string;
    /**
     * 
     * @type {Array<TemplatesdocxDocuments>}
     * @memberof TemplatesDocxBody
     */
    documents: Array<TemplatesdocxDocuments>;
}
/**
 * 
 * @export
 * @interface TemplatesHtmlBody
 */
export interface TemplatesHtmlBody {
    /**
     * HTML template with field tags.
     * @type {string}
     * @memberof TemplatesHtmlBody
     */
    html: string;
    /**
     * HTML template of the header to be displayed on every page.
     * @type {string}
     * @memberof TemplatesHtmlBody
     */
    htmlHeader?: string;
    /**
     * HTML template of the footer to be displayed on every page.
     * @type {string}
     * @memberof TemplatesHtmlBody
     */
    htmlFooter?: string;
    /**
     * Template name. Random uuid will be assigned when not specified.
     * @type {string}
     * @memberof TemplatesHtmlBody
     */
    name?: string;
    /**
     * Page size. Letter 8.5 x 11 will be assigned when not specified.
     * @type {string}
     * @memberof TemplatesHtmlBody
     */
    size?: TemplatesHtmlBody.SizeEnum;
    /**
     * Your application-specific unique string key to identify this template within your app. Existing template with specified `external_id` will be updated with a new HTML.
     * @type {string}
     * @memberof TemplatesHtmlBody
     */
    externalId?: string;
    /**
     * The folder's name to which the template should be created.
     * @type {string}
     * @memberof TemplatesHtmlBody
     */
    folderName?: string;
    /**
     * The list of documents built from HTML. Can be used to create a template with multiple documents. Leave `documents` param empty when using a top-level `html` param for a template with a single document.
     * @type {Array<TemplateshtmlDocuments>}
     * @memberof TemplatesHtmlBody
     */
    documents?: Array<TemplateshtmlDocuments>;
}

/**
 * @export
 * @namespace TemplatesHtmlBody
 */
export namespace TemplatesHtmlBody {
    /**
     * @export
     * @enum {string}
     */
    export enum SizeEnum {
        Letter = <any>'Letter',
        Legal = <any>'Legal',
        Tabloid = <any>'Tabloid',
        Ledger = <any>'Ledger',
        A0 = <any>'A0',
        A1 = <any>'A1',
        A2 = <any>'A2',
        A3 = <any>'A3',
        A4 = <any>'A4',
        A5 = <any>'A5',
        A6 = <any>'A6'
    }
}
/**
 * 
 * @export
 * @interface TemplatesIdBody
 */
export interface TemplatesIdBody {
    /**
     * The name of the template
     * @type {string}
     * @memberof TemplatesIdBody
     */
    name?: string;
    /**
     * The folder's name to which the template should be moved
     * @type {string}
     * @memberof TemplatesIdBody
     */
    folderName?: string;
    /**
     * An array of submitter role names to update the template with.
     * @type {Array<string>}
     * @memberof TemplatesIdBody
     */
    roles?: Array<string>;
    /**
     * Set `false` to unarchive template.
     * @type {boolean}
     * @memberof TemplatesIdBody
     */
    archived?: boolean;
}
/**
 * 
 * @export
 * @interface TemplatesMergeBody
 */
export interface TemplatesMergeBody {
    /**
     * An array of template ids to merge into a new template.
     * @type {Array<number>}
     * @memberof TemplatesMergeBody
     */
    templateIds: Array<number>;
    /**
     * Template name. Existing name with (Merged) suffix will be used if not specified.
     * @type {string}
     * @memberof TemplatesMergeBody
     */
    name?: string;
    /**
     * The name of the folder in which the merged template should be placed.
     * @type {string}
     * @memberof TemplatesMergeBody
     */
    folderName?: string;
    /**
     * Your application-specific unique string key to identify this template within your app.
     * @type {string}
     * @memberof TemplatesMergeBody
     */
    externalId?: string;
}
/**
 * 
 * @export
 * @interface TemplatesPdfBody
 */
export interface TemplatesPdfBody {
    /**
     * Name of the template
     * @type {string}
     * @memberof TemplatesPdfBody
     */
    name?: string;
    /**
     * The folder's name to which the template should be created.
     * @type {string}
     * @memberof TemplatesPdfBody
     */
    folderName?: string;
    /**
     * Your application-specific unique string key to identify this template within your app. Existing template with specified `external_id` will be updated with a new PDF.
     * @type {string}
     * @memberof TemplatesPdfBody
     */
    externalId?: string;
    /**
     * 
     * @type {Array<TemplatespdfDocuments>}
     * @memberof TemplatesPdfBody
     */
    documents: Array<TemplatespdfDocuments>;
}
/**
 * 
 * @export
 * @interface TemplatesdocxAreas
 */
export interface TemplatesdocxAreas {
    /**
     * X-coordinate of the field area
     * @type {number}
     * @memberof TemplatesdocxAreas
     */
    x?: number;
    /**
     * Y-coordinate of the field area
     * @type {number}
     * @memberof TemplatesdocxAreas
     */
    y?: number;
    /**
     * Width of the field area
     * @type {number}
     * @memberof TemplatesdocxAreas
     */
    w?: number;
    /**
     * Height of the field area
     * @type {number}
     * @memberof TemplatesdocxAreas
     */
    h?: number;
    /**
     * Page number of the field area. Starts from 1.
     * @type {number}
     * @memberof TemplatesdocxAreas
     */
    page?: number;
}
/**
 * 
 * @export
 * @interface TemplatesdocxDocuments
 */
export interface TemplatesdocxDocuments {
    /**
     * Name of the document
     * @type {string}
     * @memberof TemplatesdocxDocuments
     */
    name: string;
    /**
     * Base64-encoded content of the DOCX file or downloadable file URL
     * @type {string}
     * @memberof TemplatesdocxDocuments
     */
    file: string;
    /**
     * Fields are optional if you use {{...}} text tags to define fields in the document.
     * @type {Array<TemplatesdocxFields>}
     * @memberof TemplatesdocxDocuments
     */
    fields?: Array<TemplatesdocxFields>;
}
/**
 * 
 * @export
 * @interface TemplatesdocxFields
 */
export interface TemplatesdocxFields {
    /**
     * Name of the field
     * @type {string}
     * @memberof TemplatesdocxFields
     */
    name?: string;
    /**
     * Role name of the signer
     * @type {string}
     * @memberof TemplatesdocxFields
     */
    role?: string;
    /**
     * Type of the field (e.g., text, signature, date, initials)
     * @type {string}
     * @memberof TemplatesdocxFields
     */
    type?: TemplatesdocxFields.TypeEnum;
    /**
     * 
     * @type {Array<TemplatesdocxAreas>}
     * @memberof TemplatesdocxFields
     */
    areas?: Array<TemplatesdocxAreas>;
}

/**
 * @export
 * @namespace TemplatesdocxFields
 */
export namespace TemplatesdocxFields {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Text = <any>'text',
        Signature = <any>'signature',
        Initials = <any>'initials',
        Date = <any>'date',
        Image = <any>'image',
        File = <any>'file',
        Payment = <any>'payment',
        Stamp = <any>'stamp',
        Select = <any>'select',
        Checkbox = <any>'checkbox',
        Multiple = <any>'multiple',
        Radio = <any>'radio',
        Cells = <any>'cells',
        Phone = <any>'phone'
    }
}
/**
 * 
 * @export
 * @interface TemplateshtmlDocuments
 */
export interface TemplateshtmlDocuments {
    /**
     * HTML template with field tags.
     * @type {string}
     * @memberof TemplateshtmlDocuments
     */
    html: string;
    /**
     * Template name. Random uuid will be assigned when not specified.
     * @type {string}
     * @memberof TemplateshtmlDocuments
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface TemplatesiddocumentsDocuments
 */
export interface TemplatesiddocumentsDocuments {
    /**
     * Document name. Random uuid will be assigned when not specified.
     * @type {string}
     * @memberof TemplatesiddocumentsDocuments
     */
    name?: string;
    /**
     * Base64-encoded content of the PDF or DOCX file or downloadable file URL. Leave it empty if you create a new document using HTML param.
     * @type {string}
     * @memberof TemplatesiddocumentsDocuments
     */
    file?: string;
    /**
     * HTML template with field tags. Leave it empty if you add a document via PDF or DOCX base64 encoded file param or URL.
     * @type {string}
     * @memberof TemplatesiddocumentsDocuments
     */
    html?: string;
    /**
     * Position of the document. By default will be added as the last document in the template.
     * @type {number}
     * @memberof TemplatesiddocumentsDocuments
     */
    position?: number;
    /**
     * Set to `true` to replace existing document with a new file at `position`. Existing document fields will be transferred to the new document if it doesn't contain any fields
     * @type {boolean}
     * @memberof TemplatesiddocumentsDocuments
     */
    replace?: boolean;
    /**
     * Set to `true` to remove existing document at given `position` or with given `name`.
     * @type {boolean}
     * @memberof TemplatesiddocumentsDocuments
     */
    remove?: boolean;
}
/**
 * 
 * @export
 * @interface TemplatespdfAreas
 */
export interface TemplatespdfAreas {
    /**
     * X-coordinate of the field area
     * @type {number}
     * @memberof TemplatespdfAreas
     */
    x: number;
    /**
     * Y-coordinate of the field area
     * @type {number}
     * @memberof TemplatespdfAreas
     */
    y: number;
    /**
     * Width of the field area
     * @type {number}
     * @memberof TemplatespdfAreas
     */
    w: number;
    /**
     * Height of the field area
     * @type {number}
     * @memberof TemplatespdfAreas
     */
    h: number;
    /**
     * Page number of the field area. Starts from 1.
     * @type {number}
     * @memberof TemplatespdfAreas
     */
    page: number;
}
/**
 * 
 * @export
 * @interface TemplatespdfDocuments
 */
export interface TemplatespdfDocuments {
    /**
     * Name of the document
     * @type {string}
     * @memberof TemplatespdfDocuments
     */
    name: string;
    /**
     * Base64-encoded content of the PDF file or downloadable file URL
     * @type {string}
     * @memberof TemplatespdfDocuments
     */
    file: string;
    /**
     * Fields are optional if you use {{...}} text tags to define fields in the document.
     * @type {Array<TemplatespdfFields>}
     * @memberof TemplatespdfDocuments
     */
    fields?: Array<TemplatespdfFields>;
}
/**
 * 
 * @export
 * @interface TemplatespdfFields
 */
export interface TemplatespdfFields {
    /**
     * Name of the field
     * @type {string}
     * @memberof TemplatespdfFields
     */
    name?: string;
    /**
     * Role name of the signer
     * @type {string}
     * @memberof TemplatespdfFields
     */
    role?: string;
    /**
     * Type of the field (e.g., text, signature, date, initials)
     * @type {string}
     * @memberof TemplatespdfFields
     */
    type?: TemplatespdfFields.TypeEnum;
    /**
     * 
     * @type {Array<TemplatespdfAreas>}
     * @memberof TemplatespdfFields
     */
    areas?: Array<TemplatespdfAreas>;
}

/**
 * @export
 * @namespace TemplatespdfFields
 */
export namespace TemplatespdfFields {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Text = <any>'text',
        Signature = <any>'signature',
        Initials = <any>'initials',
        Date = <any>'date',
        Image = <any>'image',
        File = <any>'file',
        Payment = <any>'payment',
        Stamp = <any>'stamp',
        Select = <any>'select',
        Checkbox = <any>'checkbox',
        Multiple = <any>'multiple',
        Radio = <any>'radio',
        Cells = <any>'cells',
        Phone = <any>'phone'
    }
}
/**
 * SubmissionsApi - fetch parameter creator
 * @export
 */
export const SubmissionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The API endpoint allows you to archive a submission.
         * @summary Archive a submission
         * @param {number} id The unique identifier of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSubmission(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling archiveSubmission.');
            }
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint allows you to create signature requests (submissions) for a document template and send them to the specified submitters (signers).<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/send-documents-for-signature-via-api\" class=\"link\">Send documents for signature via API</a><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api\" class=\"link\">Pre-fill PDF document form fields with API</a>
         * @summary Create a submission
         * @param {SubmissionsBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(body: SubmissionsBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createSubmission.');
            }
            const localVarPath = `/submissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmissionsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API endpoint allows you to create submissions for a document template and send them to the specified email addresses. This is a simplified version of the POST /submissions API to be used with Zapier or other automation tools.
         * @summary Create submissions from emails
         * @param {SubmissionsEmailsBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmissionsFromEmails(body: SubmissionsEmailsBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createSubmissionsFromEmails.');
            }
            const localVarPath = `/submissions/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmissionsEmailsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the functionality to retrieve information about a submission.
         * @summary Get a submission
         * @param {number} id The unique identifier of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getSubmission.');
            }
            const localVarPath = `/submissions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the ability to retrieve a list of available submissions.
         * @summary List all submissions
         * @param {number} [templateId] The template ID allows you to receive only the submissions created from that specific template.
         * @param {string} [q] Filter submissions based on submitters name, email or phone partial match.
         * @param {string} [templateFolder] Filter submissions by template folder name.
         * @param {number} [limit] The number of submissions to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions.
         * @param {number} [before] The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(templateId?: number, q?: string, templateFolder?: string, limit?: number, after?: number, before?: number, options: any = {}): FetchArgs {
            const localVarPath = `/submissions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['template_id'] = templateId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (templateFolder !== undefined) {
                localVarQueryParameter['template_folder'] = templateFolder;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionsApi - functional programming interface
 * @export
 */
export const SubmissionsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * The API endpoint allows you to archive a submission.
         * @summary Archive a submission
         * @param {number} id The unique identifier of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSubmission(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).archiveSubmission(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This API endpoint allows you to create signature requests (submissions) for a document template and send them to the specified submitters (signers).<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/send-documents-for-signature-via-api\" class=\"link\">Send documents for signature via API</a><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api\" class=\"link\">Pre-fill PDF document form fields with API</a>
         * @summary Create a submission
         * @param {SubmissionsBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(body: SubmissionsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2005>> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).createSubmission(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This API endpoint allows you to create submissions for a document template and send them to the specified email addresses. This is a simplified version of the POST /submissions API to be used with Zapier or other automation tools.
         * @summary Create submissions from emails
         * @param {SubmissionsEmailsBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmissionsFromEmails(body: SubmissionsEmailsBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InlineResponse2005>> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).createSubmissionsFromEmails(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the functionality to retrieve information about a submission.
         * @summary Get a submission
         * @param {number} id The unique identifier of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmission(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the ability to retrieve a list of available submissions.
         * @summary List all submissions
         * @param {number} [templateId] The template ID allows you to receive only the submissions created from that specific template.
         * @param {string} [q] Filter submissions based on submitters name, email or phone partial match.
         * @param {string} [templateFolder] Filter submissions by template folder name.
         * @param {number} [limit] The number of submissions to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions.
         * @param {number} [before] The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions(templateId?: number, q?: string, templateFolder?: string, limit?: number, after?: number, before?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmissions(templateId, q, templateFolder, limit, after, before, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmissionsApi - factory interface
 * @export
 */
export const SubmissionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The API endpoint allows you to archive a submission.
         * @summary Archive a submission
         * @param {number} id The unique identifier of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveSubmission(id: number, options?: any) {
            return SubmissionsApiFp(configuration).archiveSubmission(id, options)(fetch, basePath);
        },
        /**
         * This API endpoint allows you to create signature requests (submissions) for a document template and send them to the specified submitters (signers).<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/send-documents-for-signature-via-api\" class=\"link\">Send documents for signature via API</a><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api\" class=\"link\">Pre-fill PDF document form fields with API</a>
         * @summary Create a submission
         * @param {SubmissionsBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(body: SubmissionsBody, options?: any) {
            return SubmissionsApiFp(configuration).createSubmission(body, options)(fetch, basePath);
        },
        /**
         * This API endpoint allows you to create submissions for a document template and send them to the specified email addresses. This is a simplified version of the POST /submissions API to be used with Zapier or other automation tools.
         * @summary Create submissions from emails
         * @param {SubmissionsEmailsBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmissionsFromEmails(body: SubmissionsEmailsBody, options?: any) {
            return SubmissionsApiFp(configuration).createSubmissionsFromEmails(body, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the functionality to retrieve information about a submission.
         * @summary Get a submission
         * @param {number} id The unique identifier of the submission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission(id: number, options?: any) {
            return SubmissionsApiFp(configuration).getSubmission(id, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the ability to retrieve a list of available submissions.
         * @summary List all submissions
         * @param {number} [templateId] The template ID allows you to receive only the submissions created from that specific template.
         * @param {string} [q] Filter submissions based on submitters name, email or phone partial match.
         * @param {string} [templateFolder] Filter submissions by template folder name.
         * @param {number} [limit] The number of submissions to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions.
         * @param {number} [before] The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissions({ templateFolder, q, templateId, limit, after, before }: { templateId?: number, q?: string, templateFolder?: string, limit?: number, after?: number, before?: number }, options?: any) {
            return SubmissionsApiFp(configuration).getSubmissions(templateId, q, templateFolder, limit, after, before, options)(fetch, basePath);
        },
    };
};

/**
 * SubmissionsApi - object-oriented interface
 * @export
 * @class SubmissionsApi
 * @extends {BaseAPI}
 */
export class SubmissionsApi extends BaseAPI {
    /**
     * The API endpoint allows you to archive a submission.
     * @summary Archive a submission
     * @param {number} id The unique identifier of the submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public archiveSubmission(id: number, options?: any) {
        return SubmissionsApiFp(this.configuration).archiveSubmission(id, options)(this.fetch, this.basePath);
    }

    /**
     * This API endpoint allows you to create signature requests (submissions) for a document template and send them to the specified submitters (signers).<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/send-documents-for-signature-via-api\" class=\"link\">Send documents for signature via API</a><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api\" class=\"link\">Pre-fill PDF document form fields with API</a>
     * @summary Create a submission
     * @param {SubmissionsBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public createSubmission(body: SubmissionsBody, options?: any) {
        return SubmissionsApiFp(this.configuration).createSubmission(body, options)(this.fetch, this.basePath);
    }

    /**
     * This API endpoint allows you to create submissions for a document template and send them to the specified email addresses. This is a simplified version of the POST /submissions API to be used with Zapier or other automation tools.
     * @summary Create submissions from emails
     * @param {SubmissionsEmailsBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public createSubmissionsFromEmails(body: SubmissionsEmailsBody, options?: any) {
        return SubmissionsApiFp(this.configuration).createSubmissionsFromEmails(body, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the functionality to retrieve information about a submission.
     * @summary Get a submission
     * @param {number} id The unique identifier of the submission.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmission(id: number, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmission(id, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the ability to retrieve a list of available submissions.
     * @summary List all submissions
     * @param {number} [templateId] The template ID allows you to receive only the submissions created from that specific template.
     * @param {string} [q] Filter submissions based on submitters name, email or phone partial match.
     * @param {string} [templateFolder] Filter submissions by template folder name.
     * @param {number} [limit] The number of submissions to return. Default value is 10. Maximum value is 100.
     * @param {number} [after] The unique identifier of the submission to start the list from. It allows you to receive only submissions with an ID greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submissions.
     * @param {number} [before] The unique identifier of the submission that marks the end of the list. It allows you to receive only submissions with an ID less than the specified value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmissions({ templateFolder, q, templateId, limit, after, before }: { templateId?: number, q?: string, templateFolder?: string, limit?: number, after?: number, before?: number }, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmissions(templateId, q, templateFolder, limit, after, before, options)(this.fetch, this.basePath);
    }

}
/**
 * SubmittersApi - fetch parameter creator
 * @export
 */
export const SubmittersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The API endpoint provides the functionality to retrieve information about a submitter.
         * @summary Get a submitter
         * @param {number} id The unique identifier of the submitter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmitter(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getSubmitter.');
            }
            const localVarPath = `/submitters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the ability to retrieve a list of submitters.
         * @summary List all submitters
         * @param {number} [submissionId] The submission ID allows you to receive only the submitters related to that specific submission.
         * @param {string} [q] Filter submitters on name, email or phone partial match.
         * @param {Date} [completedAfter] The date and time string value to filter submitters that completed the submission after the specified date and time.
         * @param {Date} [completedBefore] The date and time string value to filter submitters that completed the submission before the specified date and time.
         * @param {string} [externalId] The unique applications-specific identifier provided for a submitter when initializing a signature request. It allows you to receive only submitters with a specified external id.
         * @param {number} [limit] The number of submitters to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the submitter to start the list from. It allows you to receive only submitters with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submitters.
         * @param {number} [before] The unique identifier of the submitter to end the list with. It allows you to receive only submitters with id less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmitters({ submissionId, q, completedAfter, completedBefore, externalId, limit, before, after }: { submissionId?: number, q?: string, completedAfter?: Date, completedBefore?: Date, externalId?: string, limit?: number, after?: number, before?: number }, options: any = {}): FetchArgs {
            const localVarPath = `/submitters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            if (submissionId !== undefined) {
                localVarQueryParameter['submission_id'] = submissionId;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (completedAfter !== undefined) {
                localVarQueryParameter['completed_after'] = (completedAfter as any).toISOString();
            }

            if (completedBefore !== undefined) {
                localVarQueryParameter['completed_before'] = (completedBefore as any).toISOString();
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides allows you to update submitter details, pre-fill or update field values and re-send emails.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api#automatically_sign_documents_via_api\" class=\"link\">Automatically sign documents via API</a>
         * @summary Update a submitter
         * @param {SubmittersIdBody} body 
         * @param {number} id The unique identifier of the submitter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubmitter(body: SubmittersIdBody, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateSubmitter.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateSubmitter.');
            }
            const localVarPath = `/submitters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmittersIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmittersApi - functional programming interface
 * @export
 */
export const SubmittersApiFp = function (configuration?: Configuration) {
    return {
        /**
         * The API endpoint provides the functionality to retrieve information about a submitter.
         * @summary Get a submitter
         * @param {number} id The unique identifier of the submitter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmitter(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = SubmittersApiFetchParamCreator(configuration).getSubmitter(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the ability to retrieve a list of submitters.
         * @summary List all submitters
         * @param {number} [submissionId] The submission ID allows you to receive only the submitters related to that specific submission.
         * @param {string} [q] Filter submitters on name, email or phone partial match.
         * @param {Date} [completedAfter] The date and time string value to filter submitters that completed the submission after the specified date and time.
         * @param {Date} [completedBefore] The date and time string value to filter submitters that completed the submission before the specified date and time.
         * @param {string} [externalId] The unique applications-specific identifier provided for a submitter when initializing a signature request. It allows you to receive only submitters with a specified external id.
         * @param {number} [limit] The number of submitters to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the submitter to start the list from. It allows you to receive only submitters with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submitters.
         * @param {number} [before] The unique identifier of the submitter to end the list with. It allows you to receive only submitters with id less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmitters(submissionId?: number, q?: string, completedAfter?: Date, completedBefore?: Date, externalId?: string, limit?: number, after?: number, before?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
            const localVarFetchArgs = SubmittersApiFetchParamCreator(configuration).getSubmitters({ submissionId, q, completedAfter, completedBefore, externalId, limit, after, before }, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides allows you to update submitter details, pre-fill or update field values and re-send emails.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api#automatically_sign_documents_via_api\" class=\"link\">Automatically sign documents via API</a>
         * @summary Update a submitter
         * @param {SubmittersIdBody} body 
         * @param {number} id The unique identifier of the submitter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubmitter(body: SubmittersIdBody, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
            const localVarFetchArgs = SubmittersApiFetchParamCreator(configuration).updateSubmitter(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmittersApi - factory interface
 * @export
 */
export const SubmittersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The API endpoint provides the functionality to retrieve information about a submitter.
         * @summary Get a submitter
         * @param {number} id The unique identifier of the submitter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmitter(id: number, options?: any) {
            return SubmittersApiFp(configuration).getSubmitter(id, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the ability to retrieve a list of submitters.
         * @summary List all submitters
         * @param {number} [submissionId] The submission ID allows you to receive only the submitters related to that specific submission.
         * @param {string} [q] Filter submitters on name, email or phone partial match.
         * @param {Date} [completedAfter] The date and time string value to filter submitters that completed the submission after the specified date and time.
         * @param {Date} [completedBefore] The date and time string value to filter submitters that completed the submission before the specified date and time.
         * @param {string} [externalId] The unique applications-specific identifier provided for a submitter when initializing a signature request. It allows you to receive only submitters with a specified external id.
         * @param {number} [limit] The number of submitters to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the submitter to start the list from. It allows you to receive only submitters with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submitters.
         * @param {number} [before] The unique identifier of the submitter to end the list with. It allows you to receive only submitters with id less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmitters({ submissionId, q, completedAfter, completedBefore, externalId, limit, after, before }: { submissionId?: number, q?: string, completedAfter?: Date, completedBefore?: Date, externalId?: string, limit?: number, after?: number, before?: number }, options?: any) {
            return SubmittersApiFp(configuration).getSubmitters(submissionId, q, completedAfter, completedBefore, externalId, limit, after, before, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides allows you to update submitter details, pre-fill or update field values and re-send emails.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api#automatically_sign_documents_via_api\" class=\"link\">Automatically sign documents via API</a>
         * @summary Update a submitter
         * @param {SubmittersIdBody} body 
         * @param {number} id The unique identifier of the submitter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubmitter(body: SubmittersIdBody, id: number, options?: any) {
            return SubmittersApiFp(configuration).updateSubmitter(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * SubmittersApi - object-oriented interface
 * @export
 * @class SubmittersApi
 * @extends {BaseAPI}
 */
export class SubmittersApi extends BaseAPI {
    /**
     * The API endpoint provides the functionality to retrieve information about a submitter.
     * @summary Get a submitter
     * @param {number} id The unique identifier of the submitter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittersApi
     */
    public getSubmitter(id: number, options?: any) {
        return SubmittersApiFp(this.configuration).getSubmitter(id, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the ability to retrieve a list of submitters.
     * @summary List all submitters
     * @param {number} [submissionId] The submission ID allows you to receive only the submitters related to that specific submission.
     * @param {string} [q] Filter submitters on name, email or phone partial match.
     * @param {Date} [completedAfter] The date and time string value to filter submitters that completed the submission after the specified date and time.
     * @param {Date} [completedBefore] The date and time string value to filter submitters that completed the submission before the specified date and time.
     * @param {string} [externalId] The unique applications-specific identifier provided for a submitter when initializing a signature request. It allows you to receive only submitters with a specified external id.
     * @param {number} [limit] The number of submitters to return. Default value is 10. Maximum value is 100.
     * @param {number} [after] The unique identifier of the submitter to start the list from. It allows you to receive only submitters with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of submitters.
     * @param {number} [before] The unique identifier of the submitter to end the list with. It allows you to receive only submitters with id less than the specified value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittersApi
     */
    public getSubmitters({ submissionId, q, completedAfter, completedBefore, externalId, limit, after, before }: { submissionId?: number; q?: string; completedAfter?: Date; completedBefore?: Date; externalId?: string; limit?: number; after?: number; before?: number; } = {}, options?: any) {
        return SubmittersApiFp(this.configuration).getSubmitters(submissionId, q, completedAfter, completedBefore, externalId, limit, after, before, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides allows you to update submitter details, pre-fill or update field values and re-send emails.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/pre-fill-pdf-document-form-fields-with-api#automatically_sign_documents_via_api\" class=\"link\">Automatically sign documents via API</a>
     * @summary Update a submitter
     * @param {SubmittersIdBody} body 
     * @param {number} id The unique identifier of the submitter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmittersApi
     */
    public updateSubmitter(body: SubmittersIdBody, id: number, options?: any) {
        return SubmittersApiFp(this.configuration).updateSubmitter(body, id, options)(this.fetch, this.basePath);
    }

}
/**
 * TemplatesApi - fetch parameter creator
 * @export
 */
export const TemplatesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The API endpoint allows you to add, remove or replace documents in the template with provided PDF/DOCX file or HTML content.
         * @summary Update template documents
         * @param {IdDocumentsBody} body 
         * @param {number} id The unique identifier of the documents template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentToTemplate(body: IdDocumentsBody, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling addDocumentToTemplate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling addDocumentToTemplate.');
            }
            const localVarPath = `/templates/{id}/documents`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdDocumentsBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint allows you to archive a document template.
         * @summary Archive a template
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveTemplate(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling archiveTemplate.');
            }
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint allows you to clone existing template into a new template.
         * @summary Clone a template
         * @param {IdCloneBody} body 
         * @param {number} id The unique identifier of the documents template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneTemplate(body: IdCloneBody, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling cloneTemplate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling cloneTemplate.');
            }
            const localVarPath = `/templates/{id}/clone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdCloneBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the functionality to create a fillable document template for existing Microsoft Word document. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.docx\" target=\"_blank\" class=\"link font-bold\" >https://www.docuseal.co/examples/fieldtags.docx</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
         * @summary Create a template from Word DOCX
         * @param {TemplatesDocxBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromDocx(body: TemplatesDocxBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createTemplateFromDocx.');
            }
            const localVarPath = `/templates/docx`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplatesDocxBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the functionality to seamlessly generate a PDF document template by utilizing the provided HTML content while incorporating pre-defined fields.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/create-pdf-document-fillable-form-with-html-api\" class=\"link\">Create PDF document fillable form with HTML</a>
         * @summary Create a template from HTML
         * @param {TemplatesHtmlBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromHtml(body: TemplatesHtmlBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createTemplateFromHtml.');
            }
            const localVarPath = `/templates/html`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplatesHtmlBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the functionality to create a fillable document template for existing PDF file. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.pdf\" target=\"_blank\" class=\"link font-bold\">https://www.docuseal.co/examples/fieldtags.pdf</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
         * @summary Create a template from existing PDF
         * @param {TemplatesPdfBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromPdf(body: TemplatesPdfBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createTemplateFromPdf.');
            }
            const localVarPath = `/templates/pdf`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplatesPdfBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the functionality to retrieve information about a document template.
         * @summary Get a template
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getTemplate.');
            }
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the ability to retrieve a list of available document templates.
         * @summary List all templates
         * @param {string} [q] Filter templates based on the name partial match.
         * @param {string} [externalId] The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id.
         * @param {string} [folder] Filter templates by folder name.
         * @param {boolean} [archived] Get only archived templates instead of active ones.
         * @param {number} [limit] The number of templates to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates.
         * @param {number} [before] The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(q?: string, externalId?: string, folder?: string, archived?: boolean, limit?: number, after?: number, before?: number, options: any = {}): FetchArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (externalId !== undefined) {
                localVarQueryParameter['external_id'] = externalId;
            }

            if (folder !== undefined) {
                localVarQueryParameter['folder'] = folder;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint allows you to merge multiple templates with documents and fields into a new combined template.
         * @summary Merge templates
         * @param {TemplatesMergeBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeTemplate(body: TemplatesMergeBody, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling mergeTemplate.');
            }
            const localVarPath = `/templates/merge`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplatesMergeBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The API endpoint provides the functionality to move a document template to a different folder and update the name of the template.
         * @summary Update a template
         * @param {TemplatesIdBody} body 
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(body: TemplatesIdBody, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateTemplate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateTemplate.');
            }
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-Auth-Token")
                    : configuration.apiKey;
                localVarHeaderParameter["X-Auth-Token"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplatesIdBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * The API endpoint allows you to add, remove or replace documents in the template with provided PDF/DOCX file or HTML content.
         * @summary Update template documents
         * @param {IdDocumentsBody} body 
         * @param {number} id The unique identifier of the documents template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentToTemplate(body: IdDocumentsBody, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).addDocumentToTemplate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint allows you to archive a document template.
         * @summary Archive a template
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveTemplate(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).archiveTemplate(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint allows you to clone existing template into a new template.
         * @summary Clone a template
         * @param {IdCloneBody} body 
         * @param {number} id The unique identifier of the documents template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneTemplate(body: IdCloneBody, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).cloneTemplate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the functionality to create a fillable document template for existing Microsoft Word document. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.docx\" target=\"_blank\" class=\"link font-bold\" >https://www.docuseal.co/examples/fieldtags.docx</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
         * @summary Create a template from Word DOCX
         * @param {TemplatesDocxBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromDocx(body: TemplatesDocxBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).createTemplateFromDocx(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the functionality to seamlessly generate a PDF document template by utilizing the provided HTML content while incorporating pre-defined fields.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/create-pdf-document-fillable-form-with-html-api\" class=\"link\">Create PDF document fillable form with HTML</a>
         * @summary Create a template from HTML
         * @param {TemplatesHtmlBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromHtml(body: TemplatesHtmlBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).createTemplateFromHtml(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the functionality to create a fillable document template for existing PDF file. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.pdf\" target=\"_blank\" class=\"link font-bold\">https://www.docuseal.co/examples/fieldtags.pdf</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
         * @summary Create a template from existing PDF
         * @param {TemplatesPdfBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromPdf(body: TemplatesPdfBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).createTemplateFromPdf(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the functionality to retrieve information about a document template.
         * @summary Get a template
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).getTemplate(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the ability to retrieve a list of available document templates.
         * @summary List all templates
         * @param {string} [q] Filter templates based on the name partial match.
         * @param {string} [externalId] The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id.
         * @param {string} [folder] Filter templates by folder name.
         * @param {boolean} [archived] Get only archived templates instead of active ones.
         * @param {number} [limit] The number of templates to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates.
         * @param {number} [before] The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(q?: string, externalId?: string, folder?: string, archived?: boolean, limit?: number, after?: number, before?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).getTemplates(q, externalId, folder, archived, limit, after, before, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint allows you to merge multiple templates with documents and fields into a new combined template.
         * @summary Merge templates
         * @param {TemplatesMergeBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeTemplate(body: TemplatesMergeBody, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).mergeTemplate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The API endpoint provides the functionality to move a document template to a different folder and update the name of the template.
         * @summary Update a template
         * @param {TemplatesIdBody} body 
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(body: TemplatesIdBody, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = TemplatesApiFetchParamCreator(configuration).updateTemplate(body, id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * The API endpoint allows you to add, remove or replace documents in the template with provided PDF/DOCX file or HTML content.
         * @summary Update template documents
         * @param {IdDocumentsBody} body 
         * @param {number} id The unique identifier of the documents template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentToTemplate(body: IdDocumentsBody, id: number, options?: any) {
            return TemplatesApiFp(configuration).addDocumentToTemplate(body, id, options)(fetch, basePath);
        },
        /**
         * The API endpoint allows you to archive a document template.
         * @summary Archive a template
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveTemplate(id: number, options?: any) {
            return TemplatesApiFp(configuration).archiveTemplate(id, options)(fetch, basePath);
        },
        /**
         * The API endpoint allows you to clone existing template into a new template.
         * @summary Clone a template
         * @param {IdCloneBody} body 
         * @param {number} id The unique identifier of the documents template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneTemplate(body: IdCloneBody, id: number, options?: any) {
            return TemplatesApiFp(configuration).cloneTemplate(body, id, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the functionality to create a fillable document template for existing Microsoft Word document. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.docx\" target=\"_blank\" class=\"link font-bold\" >https://www.docuseal.co/examples/fieldtags.docx</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
         * @summary Create a template from Word DOCX
         * @param {TemplatesDocxBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromDocx(body: TemplatesDocxBody, options?: any) {
            return TemplatesApiFp(configuration).createTemplateFromDocx(body, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the functionality to seamlessly generate a PDF document template by utilizing the provided HTML content while incorporating pre-defined fields.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/create-pdf-document-fillable-form-with-html-api\" class=\"link\">Create PDF document fillable form with HTML</a>
         * @summary Create a template from HTML
         * @param {TemplatesHtmlBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromHtml(body: TemplatesHtmlBody, options?: any) {
            return TemplatesApiFp(configuration).createTemplateFromHtml(body, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the functionality to create a fillable document template for existing PDF file. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.pdf\" target=\"_blank\" class=\"link font-bold\">https://www.docuseal.co/examples/fieldtags.pdf</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
         * @summary Create a template from existing PDF
         * @param {TemplatesPdfBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateFromPdf(body: TemplatesPdfBody, options?: any) {
            return TemplatesApiFp(configuration).createTemplateFromPdf(body, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the functionality to retrieve information about a document template.
         * @summary Get a template
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(id: number, options?: any) {
            return TemplatesApiFp(configuration).getTemplate(id, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the ability to retrieve a list of available document templates.
         * @summary List all templates
         * @param {string} [q] Filter templates based on the name partial match.
         * @param {string} [externalId] The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id.
         * @param {string} [folder] Filter templates by folder name.
         * @param {boolean} [archived] Get only archived templates instead of active ones.
         * @param {number} [limit] The number of templates to return. Default value is 10. Maximum value is 100.
         * @param {number} [after] The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates.
         * @param {number} [before] The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates({ q, externalId, folder, archived, limit, after, before }: { q?: string, externalId?: string, folder?: string, archived?: boolean, limit?: number, after?: number, before?: number }, options?: any) {
            return TemplatesApiFp(configuration).getTemplates(q, externalId, folder, archived, limit, after, before, options)(fetch, basePath);
        },
        /**
         * The API endpoint allows you to merge multiple templates with documents and fields into a new combined template.
         * @summary Merge templates
         * @param {TemplatesMergeBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeTemplate(body: TemplatesMergeBody, options?: any) {
            return TemplatesApiFp(configuration).mergeTemplate(body, options)(fetch, basePath);
        },
        /**
         * The API endpoint provides the functionality to move a document template to a different folder and update the name of the template.
         * @summary Update a template
         * @param {TemplatesIdBody} body 
         * @param {number} id The unique identifier of the document template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(body: TemplatesIdBody, id: number, options?: any) {
            return TemplatesApiFp(configuration).updateTemplate(body, id, options)(fetch, basePath);
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * The API endpoint allows you to add, remove or replace documents in the template with provided PDF/DOCX file or HTML content.
     * @summary Update template documents
     * @param {IdDocumentsBody} body 
     * @param {number} id The unique identifier of the documents template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public addDocumentToTemplate(body: IdDocumentsBody, id: number, options?: any) {
        return TemplatesApiFp(this.configuration).addDocumentToTemplate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint allows you to archive a document template.
     * @summary Archive a template
     * @param {number} id The unique identifier of the document template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public archiveTemplate(id: number, options?: any) {
        return TemplatesApiFp(this.configuration).archiveTemplate(id, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint allows you to clone existing template into a new template.
     * @summary Clone a template
     * @param {IdCloneBody} body 
     * @param {number} id The unique identifier of the documents template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public cloneTemplate(body: IdCloneBody, id: number, options?: any) {
        return TemplatesApiFp(this.configuration).cloneTemplate(body, id, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the functionality to create a fillable document template for existing Microsoft Word document. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.docx\" target=\"_blank\" class=\"link font-bold\" >https://www.docuseal.co/examples/fieldtags.docx</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
     * @summary Create a template from Word DOCX
     * @param {TemplatesDocxBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplateFromDocx(body: TemplatesDocxBody, options?: any) {
        return TemplatesApiFp(this.configuration).createTemplateFromDocx(body, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the functionality to seamlessly generate a PDF document template by utilizing the provided HTML content while incorporating pre-defined fields.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/create-pdf-document-fillable-form-with-html-api\" class=\"link\">Create PDF document fillable form with HTML</a>
     * @summary Create a template from HTML
     * @param {TemplatesHtmlBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplateFromHtml(body: TemplatesHtmlBody, options?: any) {
        return TemplatesApiFp(this.configuration).createTemplateFromHtml(body, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the functionality to create a fillable document template for existing PDF file. Use <code>{{Field Name;role=Signer1;type=date}}</code> text tags to define fillable fields in the document. See <a href=\"https://www.docuseal.co/examples/fieldtags.pdf\" target=\"_blank\" class=\"link font-bold\">https://www.docuseal.co/examples/fieldtags.pdf</a> for more text tag formats. Or specify the exact pixel coordinates of the document fields using `fields` param.<br><b>Related Guides</b><br><a href=\"https://www.docuseal.co/guides/use-embedded-text-field-tags-in-the-pdf-to-create-a-fillable-form\" class=\"link\">Use embedded text field tags to create a fillable form</a> 
     * @summary Create a template from existing PDF
     * @param {TemplatesPdfBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplateFromPdf(body: TemplatesPdfBody, options?: any) {
        return TemplatesApiFp(this.configuration).createTemplateFromPdf(body, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the functionality to retrieve information about a document template.
     * @summary Get a template
     * @param {number} id The unique identifier of the document template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(id: number, options?: any) {
        return TemplatesApiFp(this.configuration).getTemplate(id, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the ability to retrieve a list of available document templates.
     * @summary List all templates
     * @param {string} [q] Filter templates based on the name partial match.
     * @param {string} [externalId] The unique applications-specific identifier provided for the template via API or Embedded template form builder. It allows you to receive only templates with your specified external id.
     * @param {string} [folder] Filter templates by folder name.
     * @param {boolean} [archived] Get only archived templates instead of active ones.
     * @param {number} [limit] The number of templates to return. Default value is 10. Maximum value is 100.
     * @param {number} [after] The unique identifier of the template to start the list from. It allows you to receive only templates with id greater than the specified value. Pass ID value from the &#x60;pagination.next&#x60; response to load the next batch of templates.
     * @param {number} [before] The unique identifier of the template to end the list with. It allows you to receive only templates with id less than the specified value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplates({ q, externalId, folder, after, before, limit, archived }: { q?: string, externalId?: string, folder?: string, archived?: boolean, limit?: number, after?: number, before?: number } = {}, options?: any) {
        return TemplatesApiFp(this.configuration).getTemplates(q, externalId, folder, archived, limit, after, before, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint allows you to merge multiple templates with documents and fields into a new combined template.
     * @summary Merge templates
     * @param {TemplatesMergeBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public mergeTemplate(body: TemplatesMergeBody, options?: any) {
        return TemplatesApiFp(this.configuration).mergeTemplate(body, options)(this.fetch, this.basePath);
    }

    /**
     * The API endpoint provides the functionality to move a document template to a different folder and update the name of the template.
     * @summary Update a template
     * @param {TemplatesIdBody} body 
     * @param {number} id The unique identifier of the document template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplate(body: TemplatesIdBody, id: number, options?: any) {
        return TemplatesApiFp(this.configuration).updateTemplate(body, id, options)(this.fetch, this.basePath);
    }

}
